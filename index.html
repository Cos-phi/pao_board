<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=750">
    <link rel="icon" href="image/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="image/apple-touch-icon.png">
    <title>pao_board</title>
    <link rel="stylesheet" type="text/css" href="style.css?v=19"> <!--v=の値を変えることで、CSSのキャッシュを破棄して再読み込みしてもらいますわ-->
</head>
<body>
    <div id="app">
        <div id="controls-top">
            <div class="top-left-buttons">
                <button id="clear" class="controls-top-button" title="キャンバスのクリア/Clear Canvas">
                    <img class="svg-button" src="image/new.svg" style="height: 100%;" alt="Clear">
                </button>
                <button id="manual" class="controls-top-button" title="pao_boardについて/About pao_board">
                    <img class="svg-button" src="image/manual.svg" style="height: 100%;" alt="Manual">
                </button>
            </div>

            <div class="top-right-buttons">
                <button id="copy-button" class="controls-top-button" title="クリップボードにコピー/Copy to Clipboard">
                    <img class="svg-button" src="image/copytoclipboard.svg" style="height: 100%;" alt="Copy">
                </button>
                <button id="save-button" class="controls-top-button" title="ダウンロードして保存/Save to Download">
                    <img class="svg-button" src="image/download.svg" style="height: 100%;" alt="Download">
                </button>
                <button id="share-button" class="controls-top-button" title="共有/Share">
                    <img class="svg-button" src="image/share.svg" style="height: 100%;" alt="Share">
                </button>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="color-layer"></canvas>
            <canvas id="black-layer"></canvas>
            <div id="cursor"></div>
        </div>

        <div id="hashtag-line">
            <button id="copy-hashtag" class="copy-hashtag-button" title="ハッシュタグをコピー/Copy Hashtag">
                <span id="hashtag-text">#pao_board</span>
                <img class="svg-button" src="image/copytoclipboard.svg" class="icon" alt="Copy hashtag">
            </button>
        </div>   
        
        <div id="message-line"></div>
        

    </div>

    <script>
        //HTML要素の取得
        const clearButton = document.getElementById('clear');
        const manualButton = document.getElementById('manual');
        
        const copyButton = document.getElementById('copy-button');
        const saveButton = document.getElementById('save-button');
        const shareButton = document.getElementById('share-button');

        const canvasContainer = document.getElementById('canvas-container');
        const blackLayer = document.getElementById('black-layer');
        const colorLayer = document.getElementById('color-layer');
        const cursor = document.getElementById('cursor');
        const combinedCanvas = document.createElement('canvas');

        const hashtagLine = document.getElementById('hashtag-line');
        const messageLine = document.getElementById('message-line');
        const copyHashtagButton = document.getElementById('copy-hashtag');

        const modals = document.getElementsByClassName('modal');


        //重要な設定
        const backgroundColor = "#111117";
        const fillColor = "#36364A";
        const penColor = "#3FEFFE";
        const [canvasWidth,canvasHeight] = [720,720];
        const smoothingFactor = 0.375;
        const hashtag = '#pao_board';
        const toolDiameter = 2; //描画ツールの直径(px)

        //キャンバスの初期化
        canvasContainer.style.width = canvasWidth + 'px';
        canvasContainer.style.height = canvasHeight + 'px';
        canvasContainer.style.backgroundColor = backgroundColor;
        [combinedCanvas.width, combinedCanvas.height] = [canvasWidth, canvasHeight];
        [blackLayer.width, blackLayer.height] = [canvasWidth, canvasHeight];
        [colorLayer.width, colorLayer.height] = [canvasWidth, canvasHeight];
        const ctxBlack = blackLayer.getContext('2d',{ willReadFrequently: true });
        const ctxColor = colorLayer.getContext('2d',{ willReadFrequently: true });
        const ctxCombined = combinedCanvas.getContext('2d');




                
        //ストレージキー
        const localstorageKeyBlack = 'pbblacklayerlskey';
        const sessionstorageKeyLastClearTime = 'pblastcleartimekey';
        
        const manualUrl = "manual.html"
        const shareUrl = "https://dummyurl.example.com/pao_board"
        
        //変数の初期化
        let outputFileName = 'pao_board.png';
        let isDrawing = false;
        let [lastX,lastY] =[0,0];
        let [beforeLastX,beforeLastY] = [0,0];

        //イベントリスナーの登録
        clearButton.addEventListener('click', clearCanvas);
        
        copyButton.addEventListener('click', copyImage);
        saveButton.addEventListener('click', saveImage);
        shareButton.addEventListener('click', shareImage);

        blackLayer.addEventListener('mousedown', startDrawingMouse);
        blackLayer.addEventListener('mousemove', drawMouse);
        blackLayer.addEventListener('mouseup', stopDrawing);
        blackLayer.addEventListener('mouseout', stopDrawingMouseOut);
        blackLayer.addEventListener('mousemove', updateCursorMouse);
        blackLayer.addEventListener('touchstart', startDrawingTouch);
        blackLayer.addEventListener('touchmove', drawTouch);
        blackLayer.addEventListener('touchend', stopDrawingTouch);
        blackLayer.addEventListener('touchcancel', stopDrawingTouch);
        blackLayer.addEventListener('touchmove', updateCursorTouch);

        //初期化
        restoreLocalstorage();
        if(null === window.sessionStorage.getItem(sessionstorageKeyLastClearTime)){
            setLastClearTime();
            initializeCanvasLayers();
        }
        initializeBackgroundLayer();

        //関数

        //描画に関する関数
        function startDrawing(x, y) {
            isDrawing = true;
            [lastX, lastY] = [x, y];
            [beforeLastX,beforeLastY] = [x,y]
            stipple(x,y);
        }

        function draw(x, y) {
            if (!isDrawing) return;
            ctxBlack.beginPath();
            ctxBlack.moveTo(lastX, lastY);
            const travelSquared = (x-lastX)**2 + (y-lastY)**2;
            if(64 < travelSquared){
                const [xM,yM] = [lastX + (x - beforeLastX)/4, lastY + (y - beforeLastY)/4]; 
                ctxBlack.lineTo(xM, yM); //移動量が多いとき、補間点を作って経由します
                [lastX,lastY] = [xM,yM];
            }else{
                console.log(`Smoothed  (${x},${y})`);
                x = x*(1-smoothingFactor) + lastX*smoothingFactor;
                y = y*(1-smoothingFactor) + lastY*smoothingFactor;
                console.log(`to (${x},${y})`);
            }
            ctxBlack.lineTo(x, y);
            ctxBlack.globalCompositeOperation = 'destination-out';
            ctxBlack.lineWidth = toolDiameter;
            ctxBlack.lineCap = 'round';
            ctxBlack.stroke();
            
            [beforeLastX,beforeLastY] = [lastX,lastY];
            [lastX, lastY] = [x, y];
        }

        function stipple(x,y){
            ctxBlack.beginPath();
            ctxBlack.moveTo(x, y);
            ctxBlack.globalCompositeOperation = 'destination-out';
            ctxBlack.arc(x,y, toolDiameter*0.5, 0, 2*Math.PI, true);
            ctxBlack.closePath();
            ctxBlack.fill();
        }

        function stopDrawing() {
            isDrawing = false;
            saveLocalstorage();
        }

        function stopDrawingMouseOut(){
            stopDrawing();
            setCursorInvisible();
        }

        function updateCursor(x, y) {            
            setCursorVisible();
            cursor.style.width = `${toolDiameter}px`;
            cursor.style.height = `${toolDiameter}px`;
            cursor.style.left = `${x - toolDiameter * 0.5}px`;
            cursor.style.top = `${y - toolDiameter * 0.5}px`;
        }

        function startDrawingMouse(e) {
            startDrawing(e.offsetX, e.offsetY);
        }

        function drawMouse(e) {
            draw(e.offsetX, e.offsetY);
        }
            
        function updateCursorMouse(e) {
            updateCursor(e.offsetX, e.offsetY);
        }

        function touchToOffsetXY(e) {
            const target = e.touches[0].target;
            const r = target.getBoundingClientRect();
            return [e.touches[0].clientX - r.left, e.touches[0].clientY - r.top];
        }

        function startDrawingTouch(e) {
            e.preventDefault();
            startDrawing(...touchToOffsetXY(e));
        }

        function drawTouch(e) {
            e.preventDefault();
            draw(...touchToOffsetXY(e));
        }
        
        function stopDrawingTouch() {
            stopDrawing();
            setCursorInvisible();
        }
            
        function updateCursorTouch(e) {
            e.preventDefault();
            updateCursor(...touchToOffsetXY(e));
        }
        
        //製作中の絵の保存・読込に関する関数
        function saveLocalstorage() {
            saveLayeronlocalstorage(localstorageKeyBlack,blackLayer);    
        }
        
        function saveLayeronlocalstorage(localstoragekey,layer){
            window.localStorage.setItem(localstoragekey,layer.toDataURL());
        }

        function restoreLocalstorage() {
            restoreLayeronlocalstorage(localstorageKeyBlack,blackLayer);
        }

        function restoreLayeronlocalstorage(localstoragekey,layer) {
            let base64blacklayer = window.localStorage.getItem(localstoragekey);
            if ( base64blacklayer != null) {
                let image = new Image();
                image.src = base64blacklayer;
                image.onload = function(){
                    layer.getContext('2d').drawImage(image,0,0);
                }
            }
        }
        
        function initializeCanvasLayers(){
            // ensure we draw normally when initializing (drawing operations
            // may set globalCompositeOperation to 'destination-out' for erasing)
            ctxBlack.globalCompositeOperation = 'source-over';
            ctxBlack.fillStyle = fillColor;
            ctxBlack.fillRect(0,0, canvasWidth,canvasHeight);
            // after initializing background, leave composite mode for drawing
            // draw operations explicitly set destination-out when erasing, so
            // we don't change it here permanently.

            console.log('Canvas layers initialized.');
        }

        function initializeBackgroundLayer(){
            ctxColor.globalCompositeOperation = 'source-over';
            ctxColor.fillStyle = penColor;
            ctxColor.fillRect(0,0, canvasWidth,canvasHeight);
            console.log('Background layer initialized.');
        }
        
        //リロード・URLクリーンアップに関する関数
        function reloadPage(){
            saveLocalstorage();
            location.reload()
        }


        //キャンバスクリア・経過時間表示に関する関数
        function clearCanvas() {
            initializeCanvasLayers();
            // update last clear time and persist cleared canvas in localStorage
            setLastClearTime();
            saveLocalstorage();
            showMessage('キャンバスをクリアしました');
        }

        function setLastClearTime(){
            const nowTime = new Date();
            window.sessionStorage.setItem(sessionstorageKeyLastClearTime,nowTime.getTime());
        }

        function getElapsedTimeMinFromLastClearTime(){
            const lastClearTime = window.sessionStorage.getItem(sessionstorageKeyLastClearTime);
            const nowTime = new Date();
            const elapsedTimeMin = Math.trunc((nowTime.getTime() - lastClearTime)/1000/60);
            return elapsedTimeMin;
        }
        
        function showElapsedTimeFromLastClearTime(){
            const elapsedTimeMin = getElapsedTimeMinFromLastClearTime();
            showMessage(`${elapsedTimeMin} 分 お絵かきしました。` );
        }

        //マニュアル表示
        function openManual(){
            location.href = manualUrl;
        }


        
        function setCursorVisible(){
            cursor.style.borderWidth = '2px';
        }

        function setCursorInvisible(){
            cursor.style.borderWidth = '0px';
        }



        //絵の保存に関する関数
        function combineCanvas() {
            ctxCombined.fillStyle = backgroundColor;
            ctxCombined.fillRect(0,0,canvasWidth,canvasHeight);
            ctxCombined.drawImage(colorLayer, 0, 0);
            ctxCombined.drawImage(blackLayer, 0, 0);
        }

        function dataURLToBlob(dataURL) {
            const parts = dataURL.split(';base64,');
            const contentType = parts[0].split(':')[1];
            const raw = window.atob(parts[1]);
            const rawLength = raw.length;
            const uInt8Array = new Uint8Array(rawLength);
            for (let i = 0; i < rawLength; ++i) {
                uInt8Array[i] = raw.charCodeAt(i);
            }
            return new Blob([uInt8Array], { type: contentType });
        }

        function setOutputFileName(){
            const nowTime = new Date();
            const timeString = nowTime.toLocaleString("ja-JP", {year: "numeric",month: "2-digit", day: "2-digit", hour:"2-digit", minute:"2-digit"}).replaceAll('/', '').replaceAll(':','').replaceAll(' ','-');
            outputFileName = timeString + '_pao_board(' + getElapsedTimeMinFromLastClearTime() +'min).png';
        }


        function copyImage() {
            combineCanvas();
            combinedCanvas.toBlob(async (blob) => {
                const item = new ClipboardItem({'image/png': blob});
                await navigator.clipboard.write([item]);
            })
            showMessage('画像をクリップボードにコピーしました');
            showElapsedTimeFromLastClearTime();
        }

        function saveImage() {
            combineCanvas();    
            setOutputFileName();        
            const dataURL = combinedCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = outputFileName;
            link.href = dataURL;
            link.click();
            showElapsedTimeFromLastClearTime();
        }

        function shareImage() {
            combineCanvas();
            setOutputFileName();           
            const dataURL = combinedCanvas.toDataURL('image/png');
            const blob = dataURLToBlob(dataURL);
            const imageFile = new File([blob], outputFileName, {type: "image/png",});
            navigator.share({
                url: shareUrl,
                text: hashtag,
                title: 'pao_board',
                files: [imageFile],
            }).then(() => {
                console.log("共有しましたの");
            }).catch((error) => {
                console.log('共有できませんでしたの‥‥');
            });
            showElapsedTimeFromLastClearTime();
        }
               
        //ハッシュタグのコピーに関する関数
        function copyHastag() {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(hashtag).then(function () {
                    showMessage(`ハッシュタグをコピーしました`);
                }).catch(function (error) {
                    console.error('ハッシュタグのコピーに失敗しました:', error);
                    alert('ハッシュタグのコピーに失敗しましたの');
                });
            } else {
                alert('テキストをコピーできませんの');
            }
        }
        
        //下部情報表示に関する関数
        function showMessage(text) {
            showMessage.queue = showMessage.queue || [];
            showMessage.queue.push(text);
            
            async function processQueue() {
                while (showMessage.queue.length > 0) {
                    const message = showMessage.queue.shift();
                    await new Promise((resolve) => {   
                        messageLine.style.display = 'flex';
                        hashtagLine.style.display = 'none';
                        messageLine.textContent = message; 
                        
                        setTimeout(() => {
                            messageLine.style.display = 'none';
                            hashtagLine.style.display = 'flex';
                            resolve();
                        }, 1800);
                    });
                }
            }
            if (!showMessage.isProcessing) {
                showMessage.isProcessing = true;
                processQueue().then(() => {
                    showMessage.isProcessing = false;
                });
            }
        }

        //ハッシュタグコピーイベントリスナー登録
        copyHashtagButton.addEventListener('click', copyHastag);    
    </script>
</body>
</html>
